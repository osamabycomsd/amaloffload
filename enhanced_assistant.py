
import os
import json
import requests
from typing import Dict, List, Optional
from difflib import get_close_matches
import tempfile
from PIL import Image
from io import BytesIO
import re
from datetime import datetime

class EnhancedNoraAssistant:
    def __init__(self):
        self.knowledge_file = "knowledge_base.json"
        self.memory_file = "global_memory.json"
        self.learning_file = "nora_learning_data.json"
        self.history_path = "enhanced_history.json"
        
        # ุชุญููู ุงูุจูุงูุงุช
        self.knowledge = self.load_knowledge()
        self.memory = self.load_memory()
        self.chat_history = self.load_history()
        
        print("โ ุชู ุชููุฆุฉ ููุฑุง ุงููุญุณูุฉ ุจูุฌุงุญ!")

    def load_knowledge(self) -> Dict:
        """ุชุญููู ูุงุนุฏุฉ ุงููุนุฑูุฉ"""
        if os.path.exists(self.knowledge_file):
            with open(self.knowledge_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}

    def save_knowledge(self):
        """ุญูุธ ูุงุนุฏุฉ ุงููุนุฑูุฉ"""
        with open(self.knowledge_file, 'w', encoding='utf-8') as f:
            json.dump(self.knowledge, f, ensure_ascii=False, indent=2)

    def load_memory(self) -> Dict:
        """ุชุญููู ุงูุฐุงูุฑุฉ ุงูุนุงูุฉ"""
        if os.path.exists(self.memory_file):
            with open(self.memory_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}

    def save_memory(self):
        """ุญูุธ ุงูุฐุงูุฑุฉ ุงูุนุงูุฉ"""
        with open(self.memory_file, 'w', encoding='utf-8') as f:
            json.dump(self.memory, f, ensure_ascii=False, indent=2)

    def load_history(self) -> List[Dict]:
        """ุชุญููู ุณุฌู ุงููุญุงุฏุซุฉ"""
        if os.path.exists(self.history_path):
            try:
                with open(self.history_path, "r", encoding="utf-8") as f:
                    return json.load(f)
            except:
                return []
        return []

    def save_history(self):
        """ุญูุธ ุณุฌู ุงููุญุงุฏุซุฉ"""
        with open(self.history_path, "w", encoding="utf-8") as f:
            json.dump(self.chat_history, f, ensure_ascii=False, indent=2)

    def clean_text(self, text: str) -> str:
        """ุชูุธูู ุงููุต"""
        text = re.sub(r'\s+', ' ', text)
        return text.strip()

    def detect_language(self, text: str) -> str:
        """ูุดู ูุบุฉ ุงููุต"""
        arabic_chars = re.compile('[\u0600-\u06FF]')
        if arabic_chars.search(text):
            return "ar"
        return "en"

    def fix_url(self, url: str) -> str:
        """ุชุตุญูุญ ุงูุฑุงุจุท"""
        if not url.startswith(("http://", "https://")):
            return "https://" + url.lstrip("//")
        return url

    def detect_media_type(self, url: str) -> str:
        """ุชุญุฏูุฏ ููุน ุงููุณุงุฆุท"""
        url = url.lower()
        if url.endswith(('.jpg', '.jpeg', '.png', '.gif', '.webp')):
            return 'image'
        elif url.endswith(('.mp4', '.mov', '.avi', '.webm')):
            return 'video'
        elif url.endswith(('.mp3', '.wav', '.ogg', '.m4a')):
            return 'audio'
        elif url.endswith('.pdf'):
            return 'pdf'
        return 'link'

    def analyze_image_from_url(self, image_url: str) -> str:
        """ุชุญููู ุตูุฑุฉ ูู ุฑุงุจุท"""
        try:
            response = requests.get(image_url, timeout=10)
            response.raise_for_status()
            image = Image.open(BytesIO(response.content))
            return f"ุชุญููู ุงูุตูุฑุฉ: ุงูุญุฌู {image.size}ุ ุงูุตูุบุฉ {image.format}"
        except Exception as e:
            return f"ุฎุทุฃ ูู ุชุญููู ุงูุตูุฑุฉ: {str(e)}"

    def smart_auto_reply(self, message: str) -> Optional[str]:
        """ุฑุฏูุฏ ุฐููุฉ ุชููุงุฆูุฉ"""
        msg = message.strip().lower()
        
        responses = {
            "ูู ูุจุฏุฃ": "ูุนู ุงุจุฏุฃ",
            "ุงุจุฏุฃ": "ูุนู ุงุจุฏุฃ", 
            "ูุนู ุฃู ูุง": "ูุนู",
            "ูู ุชูุฏ": "ูุนู",
            "ูู ุชุฑูุฏูู": "ูุนู",
            "ูุง ูู": "ููุณ ุงูุขู",
            "ุชูุตูู": "ููุณ ุงูุขู",
            "ูู ุชุญุชุงุฌ": "ูุนูุ ุดุฑุญ ุฃูุซุฑ",
            "ุฌุงูุฒุ": "ุงุจุฏุฃ",
            "ููู ูู": "ููุงูู"
        }
        
        for key, value in responses.items():
            if key in msg:
                return value
                
        if " ุฃู " in msg:
            return msg.split(" ุฃู ")[0]
            
        return None

    def learn_new_info(self, topic: str, info: str) -> str:
        """ุชุนูู ูุนูููุฉ ุฌุฏูุฏุฉ"""
        if topic not in self.knowledge:
            self.knowledge[topic] = []
        
        if info not in self.knowledge[topic]:
            self.knowledge[topic].append({
                "content": info,
                "timestamp": datetime.utcnow().isoformat()
            })
            self.save_knowledge()
            return f"โ ุชูุช ุฅุถุงูุฉ ูุนูููุฉ ุฌุฏูุฏุฉ ุนู '{topic}'"
        
        return f"โน๏ธ ุงููุนูููุฉ ููุฌูุฏุฉ ูุณุจูุงู ุนู '{topic}'"

    def search_knowledge(self, query: str) -> str:
        """ุงูุจุญุซ ูู ูุงุนุฏุฉ ุงููุนุฑูุฉ"""
        query_clean = query.strip().lower()
        
        # ุจุญุซ ูุจุงุดุฑ
        if query_clean in self.knowledge:
            info = self.knowledge[query_clean]
            if isinstance(info, list) and info:
                return info[-1].get("content", str(info[-1]))
            return str(info)
        
        # ุจุญุซ ูู ุงูููุงุถูุน
        for topic, infos in self.knowledge.items():
            if query_clean in topic.lower():
                if isinstance(infos, list) and infos:
                    return f"ูุฌุฏุช ูุนูููุฉ ุนู '{topic}': {infos[-1].get('content', str(infos[-1]))}"
                return f"ูุฌุฏุช ูุนูููุฉ ุนู '{topic}': {str(infos)}"
        
        return None

    def generate_reply(self, user_input: str) -> str:
        """ุฅูุชุงุฌ ุงูุฑุฏ ุงูุฐูู"""
        user_input = self.clean_text(user_input)
        
        # ูุญุต ุงูุฑุฏูุฏ ุงูุชููุงุฆูุฉ ุงูุฐููุฉ
        auto_reply = self.smart_auto_reply(user_input)
        if auto_reply:
            self.memory[user_input] = auto_reply
            self.save_memory()
            return auto_reply

        # ูุญุต ุงูุฐุงูุฑุฉ
        if user_input in self.memory:
            return self.memory[user_input]

        # ุงูุจุญุซ ูู ุงููุทุงุจูุงุช ุงููุฑูุจุฉ
        matches = get_close_matches(user_input, self.memory.keys(), n=1, cutoff=0.6)
        if matches:
            return self.memory[matches[0]]

        # ุงูุจุญุซ ูู ูุงุนุฏุฉ ุงููุนุฑูุฉ
        knowledge_result = self.search_knowledge(user_input)
        if knowledge_result:
            self.memory[user_input] = knowledge_result
            self.save_memory()
            return knowledge_result

        # ูุนุงูุฌุฉ ุงูุฑูุงุจุท
        if user_input.startswith("http://") or user_input.startswith("https://"):
            return self.handle_url(user_input)

        # ุชุตุญูุญ ุงูุฑูุงุจุท ูู ุงููุต
        if '//' in user_input:
            corrected_url = self.fix_url(user_input)
            reply = f"ุชู ุชุตุญูุญ ุงูุฑุงุจุท: {corrected_url}"
        else:
            # ุฑุฏ ุงูุชุฑุงุถู ูุน ุชุนูู
            reply = f"ุดูุฑุงู ูู ุนูู ุงูุฑุณุงูุฉ: '{user_input}'. ุณุฃุชุฐูุฑ ูุฐุง ูููุฑุฉ ุงููุงุฏูุฉ."
            
            # ุชุนูู ุชููุงุฆู
            if len(user_input.split()) > 2:  # ุฅุฐุง ูุงูุช ุฌููุฉ ูุนูููุฉ
                self.learn_new_info("ูุญุงุฏุซุงุช_ุนุงูุฉ", user_input)

        # ุญูุธ ูู ุงูุฐุงูุฑุฉ
        self.memory[user_input] = reply
        self.save_memory()
        return reply

    def handle_url(self, url: str) -> str:
        """ูุนุงูุฌุฉ ุงูุฑูุงุจุท"""
        url = self.fix_url(url)
        media_type = self.detect_media_type(url)
        
        if media_type == 'image':
            analysis = self.analyze_image_from_url(url)
            reply = f"๐ผ๏ธ ุตูุฑุฉ ุชู ุชุญููููุง:\n{analysis}"
        elif media_type == 'video':
            reply = f"๐ฅ ููุฏูู ุชู ุงูุชุดุงูู: {url}"
        elif media_type == 'audio':
            reply = f"๐ต ููู ุตูุชู ุชู ุงูุชุดุงูู: {url}"
        elif media_type == 'pdf':
            reply = f"๐ ููู PDF ุชู ุงูุชุดุงูู: {url}"
        else:
            reply = f"๐ ุฑุงุจุท ููุจ: {url}"
        
        return reply

    def simulate_server_scan(self):
        """ูุญุงูุงุฉ ุงูุจุญุซ ุนู ุงูุฎูุงุฏู"""
        print("ููุฑุง: ุฃุจุญุซ ุนู ุฎูุงุฏู ูุชุงุญุฉ...")
        fake_servers = ["server-01.cloud.com", "server-02.cloud.com", "server-03.local"]
        
        for server in fake_servers:
            print(f"ููุฑุง: ุชู ุงูุนุซูุฑ ุนูู ุฎุงุฏู: {server}")
            print(f"ููุฑุง: ุฃููู ุจูุญุงูุงุฉ ุงููุณุฎ ุฅูู {server}...")
        
        return "ุชูุช ุนูููุฉ ุงููุญุงูุงุฉ ุจูุฌุงุญ โ"

    def get_stats(self) -> Dict:
        """ุฅุญุตุงุฆูุงุช ุงููุธุงู"""
        return {
            "ูุนุฑูุฉ_ูุญููุธุฉ": len(self.knowledge),
            "ุฐูุฑูุงุช": len(self.memory),
            "ุณุฌู_ูุญุงุฏุซุงุช": len(self.chat_history),
            "ุขุฎุฑ_ุชุญุฏูุซ": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

    def chat(self):
        """ุจุฏุก ุงููุญุงุฏุซุฉ ุงูุชูุงุนููุฉ"""
        print("๐ค ูุฑุญุจุงู! ุฃูุง ููุฑุง ุงููุญุณูุฉุ ูุณุงุนุฏุชู ุงูุฐููุฉ.")
        print("๐ ูุฏู ูุฏุฑุงุช ูุญุณูุฉ ูู ุงูุชุนูู ุงูุฐุงุชู ูุชุญููู ุงููุณุงุฆุท")
        print("๐ก ุงูุชุจ 'ุฎุฑูุฌ' ููุฅููุงุกุ 'ุฅุญุตุงุฆูุงุช' ูุนุฑุถ ุงูุฅุญุตุงุฆูุงุชุ 'scan' ููุจุญุซ ุนู ุฎูุงุฏู")
        print("-" * 50)
        
        while True:
            try:
                user_input = input("\n๐ง ุฃูุช: ").strip()
                
                if user_input.lower() in ["ุฎุฑูุฌ", "exit", "quit"]:
                    print("ููุฑุง: ูุน ุงูุณูุงูุฉ! ๐")
                    break
                
                elif user_input.lower() == "ุฅุญุตุงุฆูุงุช":
                    stats = self.get_stats()
                    print("๐ ุฅุญุตุงุฆูุงุช ุงููุธุงู:")
                    for key, value in stats.items():
                        print(f"   {key}: {value}")
                    continue
                
                elif user_input.lower() == "scan":
                    result = self.simulate_server_scan()
                    print(f"ููุฑุง: {result}")
                    continue
                
                elif not user_input:
                    continue
                
                # ุงูุญุตูู ุนูู ุงูุฑุฏ
                response = self.generate_reply(user_input)
                print(f"๐ค ููุฑุง: {response}")
                
                # ุญูุธ ูู ุงูุณุฌู
                self.chat_history.append({
                    "user": user_input,
                    "assistant": response,
                    "timestamp": datetime.utcnow().isoformat()
                })
                
                # ุญูุธ ุงูุณุฌู ูู 5 ุฑุณุงุฆู
                if len(self.chat_history) % 5 == 0:
                    self.save_history()
                    
            except KeyboardInterrupt:
                print("\n\nููุฑุง: ุชู ุฅููุงู ุงููุญุงุฏุซุฉ. ูุน ุงูุณูุงูุฉ! ๐")
                break
            except Exception as e:
                print(f"ููุฑุง: ุนุฐุฑุงูุ ุญุฏุซ ุฎุทุฃ: {str(e)}")

def main():
    """ุชุดุบูู ุงููุณุงุนุฏ ุงููุญุณู"""
    assistant = EnhancedNoraAssistant()
    assistant.chat()

if __name__ == "__main__":
    main()
